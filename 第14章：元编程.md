# 14.1 属性的特性

JavaScript 的属性有名字和值，但每个属性也有 3 个关联的特性，用于指定属性的行为以及你可以对它执行什么操作。

* 可写（writable）特性指定是否可以修改属性的值
* 可枚举（enumerable）特性指定是否可以通过 for/in 循环和 Object.keys() 方法枚举属性
* 可配置（configurable）特性指定是否可以删除属性，以及是否可以修改属性的特性



## Object.getOwnPropertyDescriptor()

**`要获得特定对象某个属性的属性描述符，可以调用 Object.getOwnPropertyDescriptor()`**：

```                                                                                                                                                                                                       javascript
Object.getOwnPropertyDescriptor({ x: 1 }, "x"); // { value: 1, writable: true, enumerable: true, configurable: true }

const random = {
    get octet() { return Math.floor(Math.random() * 256) }
};

Object.getOwnPropertyDescriptor(random, "octet"); // { get: /*func*/, set: undefined, enumerable: true, configurable: true }

// 对继承的属性或不存在的属性返回 undefined
Object.getOwnPropertyDescriptor({}, "x"); // undefined
Object.getOwnPropertyDescriptor({}, "toString"); // undefined
```



## Object.getOwnProperty()

```javascript
let o = {};

Object.defineProperty(o, "x", {
    value: 1,
    writable: true,
    enumerable: false,
    configurable: true
});

// 确认已经有了这个属性，而且不可枚举
o.x // 1
Object.keys(o); // []

// 现在，修改属性 x，把它设置为只读
Object.defineProperty(o, "x", { writable: false });

// 试着修改这个属性的值
o.x = 2; // 静默失败或在严格模式下抛出 TypeError
o.x; // 1

// 这个属性依然是可以配置的，因此可以像这样修改它的值
Object.defineProperty(o, "x", { value: 2 });
o.x // 2

// 把 x 由数据属性修改为访问器属性
Object.defineProperty(o, "x", { get: function() { return 0; } });
o.x // 0
```



## Object.getOwnProperties()

```javascript
let p = Object.defineProperties({}, {
    x: { value: 1, writable: true, enumerable: true, configurable: true },
    y: { value: 1, writable: true, enumerable: true, configurable: true },
    r: {
        get() { return Math.sqrt(this.x * this.x + this.y * this.y); },
        enumerable: true,
        configurable: true
    }
});

p.r // => Math.SQRT2
```





# 14.2 对象的可扩展能力

## Object.isExtensible()



## Object.preventExtensions()



## Object.seal()



## Object.isSealed()



## Object.freeze()



## Object.isFrozen()





# 14.3 prototype 特性



## Object.getPrototypeOf()



**`要查询任何对象的原型，都可以把该对象传给 Object.getPrototype()`** 

```javascript
Object.getPrototypeOf({}); // Object.prototype
Object.getPrototypeOf([]); // Array.prototype
Object.getPrototypeOf(() => {}); // Function.prototype
```



## isPrototypeOf()



**`要确定一个对象是不是另一个对象的原型（或原型链中的一环），可以使用 isPrototypeOf() 方法：`**

```javascript
let p = { x: 1 }; // 定义一个原型对象
let o = Object.create(p); // 用该原型创建一个对象
p.isPrototypeOf(o); // true，o 继承了 p
Object.prototype.isPrototypeOf(p); // true，p 继承 Object.prototype
Object.prototype.isPrototypeOf(o); // true, o 也继承 Object.prototype
```



## Object.setPrototypeOf()

```javascript
let o = { x: 1 };
let p = { y: 2};

Object.setPrototypeOf(o, p); // 把 o 的原型设置为 p
o.y; // 2，o 现在继承了属性 y
let a = [1, 2, 3];
Object.setPrototypeOf(a, p); // 把数组 a 的原型设置为 p
a.join(); // undefined，a 不再有 join() 方法
```



## __proto__

**`__proto__ 的一个有意思的用法是通过它定义对象字面量的原型：`**

```javascript
let p = { z: 3 };
let o = {
    x: 1,
    y: 2,
    __proto__: p
};

o.z; // 3，o 继承 p
```





# 14.4 公认符号



## 1. Symbol.iterator 和 Symbol.asyncIterator



## 2. Symbol.hasInstance

```javascript
let uint8 = {
    [Symbol.hasInstance](x) {
        return Number.isInteger(x) && x >= 0 && x <= 255;
    }
};

128 instanceof uint8; // true
256 instanceof uint8; // false
Math.PI instanceof uint8; // false
```





## 3. Symbol.toStringTag

**`调用一个简单 JavaScript 对象的 toString() 方法会得到字符串 "[object Object]"`**

```javascript
{}.toString() // "[object Object]"
```



**`如果调用与内置类型实例的方法相同的 Object.prototype.toString() 函数，则会得到一些有趣的结果：`**

```javascript
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(/./); // "[object RegExp]"
Object.prototype.toString.call(() => {}); // "[object Function]"
Object.prototype.toString.call(""); // "[object String]"
Object.prototype.toString.call(0); // "[object Number]"
Object.prototype.toString.call(false); // "[object Boolean]"
```



```javascript
function classof(o) {
    return Object.prototype.toString.call(o).slice(8, -1);
}

classof(null); // "Null"
classof(undefined); // "Undefined" 
classof(1); // "Number"
classof(10n**100n); // "BigInt"
classof(""); // "String"
classof(false); // "Boolean"
classof(Symbol()); // "Symbol"
classof({}); // "Object"
classof([]); // "Array"
classof(/./); // "RegExp"
classof(()=>{}); // "Function"
classof(new Map()); // "Map"
classof(new Set()); // "Set"
classof(new Date()); // "Date"
```



```javascript
class Range {
    get [Symbol.toStringTag]() { return "Range"; }
}

let r = new Range(1, 10);
Object.prototype.toString.call(r); // "[object Range]"  
```



## 4. Symbol.species





## 5. Symbol.isConcatSpreadable

```javascript
let arraylike = {
    length: 1,
    0: 1,
    [Symbol.isConcatSpreadable]: true
};

[].concat(arraylike); // [1]
```



## 6. 模式匹配符号





## 7. Symbol.toPrimitive





## 8. Symbol.unscopables





# 14.5 模板标签





# 14.6 反射 API

反射 API 包括下列函数。



## Reflect.apply(f, o, args)



## Reflect.construct(c, args, newTarget)



## Reflect.defineProperty(o, name, descriptor)



## Reflect.deleteProperty(o, name)



## Reflect.get(o, name, receiver)



## Reflect.getOwnPropertyDescriptor(o, name)



## Reflect.getPrototypeOf(o)



## Reflect.has(o, name)



## Reflect.isExtensible(o)



## Reflect.ownKeys(o)



## Reflect.preventExtensions(o)



## Reflect.set(o, name, value, receiver)



## Reflect.setPrototypeOf(o, p)

​     



| 常规语法                                         | 反射 API                                          |
| ------------------------------------------------ | ------------------------------------------------- |
| **`f.apply(o, args)`**                           | **`Reflect.apply(f, o, args)`**                   |
| **`new c(...args)`**                             | **`Reflect.construct(c, args, newTarget)`**       |
| **`Object.defineProperty(o, name, descriptor)`** | **`Reflect.defineProperty(o, name, descriptor)`** |
| **`delete o[name]`**                             | **`Reflect.deleteProperty(o, name)`**             |
| **`o[name]`**                                    | **`Reflect.get(o, name, receiver)`**              |
| **`Object.getOwnPropertyDescriptor(o, name)`**   | **`Reflect.getOwnPropertyDescriptor(o, name)`**   |
| **`Object.getPrototypeOf(o)`**                   | **`Reflect.getPrototypeOf(o)`**                   |
| **`name in o`**                                  | **`Reflect.has(o, name)`**                        |
| **`Object.isExtensible(o)`**                     | **`Reflect.isExtensible(o)`**                     |
| **`Object.getOwnPropertyNames()`**               | **`Reflect.ownKeys(o)`**                          |
| **`Object.getOwnPropertySymbols()`**             |                                                   |
| **`Object.preventExtensions(o)`**                | **`Reflect.preventExtensions(o)`**                |
| **`o[name] = value`**                            | **`Reflect.set(o, name, value, receiver)`**       |
| **`Object.setPrototypeOf(o, p)`**                | **`Reflect.setPrototypeOf(o, p)`**                |





# 14.7 代理对象

**`创建代理对象时，需要指定另外两个对象，即目标对象（target）和处理器对象（handlers）`**

```javascript
let proxy = new Proxy(target, handlers);
```



```javascript
let t = { x: 1, y: 2 };
let p = new Proxy(t, {});

p.x; // 1
delete p.y; // true，从代理上删除属性 y
t.y; // undefined，也就是从目标对象上删除了它
p.z = 3; // 在代理上定义一个新的属性
t.z; // 也就在目标上定义了这个属性
```



```javascript
let identity = new Proxy({}, {
    get(o, name, target) { return name; },
    has(o, name) { return true; },
    ownKeys(o) { throw new RangeError("Infinite number of properties") },
    getOwnPropertyDescriptor(o, name) {
        return {
            value: name,
            enumerable: false,
            writable: false,
            configurable: false
        }
    },
    set(o, name, value, target) { return false },
    deleteProperty(o, name) { return false },
    defineProperty(o, name, desc) { return false },
    isExtensible(o) { return false },
    getPrototypeOf(o) { return null },
    setPrototypeOf(o, proto) { return false }
});
```









​                            
